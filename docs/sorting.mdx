---
id: sorting
title: Searching and Sorting
sidebar_label: Searching and Sorting
---
import Card from "../src/components/Card"
import ResourceQuestion from "../src/components/ResourceQuestion"
import Tabs from '@theme/Tabs';
import TipsCaution from '../src/components/TipsCaution.js';
import TabItem from '@theme/TabItem';


## Binary Search
Binary Search is one of the underdogs algorithm that is about to become one of your favourites, everyone who knows a fair bit of coding knows this algorithm but fails to understand the potential of it, here you will unlock the potential of binary search for yourself but only if you read through completely and understand thoroughly.

<TipsCaution tip = "false" content= "Go through the step1 to step5 of binary search lessons of the codeforces article to learn in depth about the use cases of binary search outside of the box. The main theorem in the topcoder article is a gem, read it and own it." />

<ResourceQuestion resource = "true" list={[{name:"Binary Search Codeforces Tutorial",link:"https://codeforces.com/edu/course/2/lesson/6"},{name:"Binary Search Topcoder Article",link:"https://www.topcoder.com/community/competitive-programming/tutorials/binary-search/"},]}/>

<TipsCaution tip = "true" content= "Learn to identify the pattern of problems and scenarios where a particular algorithm or data structure can be applied, in this case binary search. Many of the difficult binary search problems at first look like a DP problems, but if you look closer and if you have read and understood the main theorem, you won’t have a hard time discovering that BS can be applied instead of wasting time on DP. The same goes for other data structures and algorithms." />



## Concept of Lower Bound and Upper Bound
In C++, using the STL you can easily apply binary search to find the lower bound and upper bound of an element in a container. So what is lower bound and upper bound, you ask, don’t ask just read on.


<ResourceQuestion resource = "true" list={[{name:"Binary Search Lower Bound And Upper Bound Using STL",link:"https://www.geeksforgeeks.org/binary-search-functions-in-c-stl-binary_search-lower_bound-and-upper_bound/"},]}/>


<Tabs
	defaultValue="easy"
	values={[{label: "Easy", value: "easy"},{label: "Medium", value: "medium"},{label: "Hard", value: "hard"},]}>
	<TabItem value="easy">
		<ResourceQuestion  list={[{name:"Square Root Of Integer",link:"https://www.interviewbit.com/problems/square-root-of-integer/"},]}/>
	</TabItem>
	<TabItem value="medium">
		<ResourceQuestion  list={[{name:"Matrix Median",link:"https://www.interviewbit.com/problems/matrix-median/"},{name:"Eko",link:"https://www.spoj.com/problems/EKO/"},{name:"Aggrcow",link:"https://www.spoj.com/problems/AGGRCOW/"},{name:"Search In Rotated Sorted Array",link:"https://leetcode.com/problems/search-in-rotated-sorted-array/"},]}/>
	</TabItem>
	<TabItem value="hard">
		<ResourceQuestion  list={[{name:"Painters Partition Problem",link:"https://www.interviewbit.com/problems/painters-partition-problem/"},{name:"Simple Queries",link:"https://www.interviewbit.com/problems/simple-queries/"},{name:"Subsums",link:"https://www.spoj.com/problems/SUBSUMS/"},{name:"Prata",link:"https://www.spoj.com/problems/PRATA/"},{name:"Weighted Job Scheduling Log N Time",link:"https://www.geeksforgeeks.org/weighted-job-scheduling-log-n-time/"},]}/>
	</TabItem>
</Tabs>


## Sorting
Keeping the items of an array or vector organised has many advantages, one being you get to apply binary search, but there is a catch, the catch is your sorting can become disadvantageous if it takes too much time, luckily there are a few sorting algorithms that runs in O(nlogn) while there are few which run in O(n) as well, so read on to find out about these different sorting algorithms.

Remember that sorting algorithms that run in O(n*n) time is not entirely useless, for very small ‘n’, these algorithms are preferred as they don’t  blow up and are also easier to write. However, C++ STL has got you covered you don’t have to write the sorting algorithm, just use the internal library method which will sort for you in O(nlogn) time.


### Merge Sort
Merge Sort algorithm will not just teach you how to sort but you will also learn the application of another fundamental concept of Divide and Conquer. It has a dependable time complexity of O(nlogn), but can you prove it? No you cannot, not until you have learnt the algorithm, so what are you waiting for, jump into some  action and start reading.


<ResourceQuestion resource = "true" list={[{name:"Merge Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/tutorial"},]}/>



### Quick Sort
As an alternative to merge sort is quick sort, the algorithm is quite unique and surely worth your efforts. Like merge sort it also applies Divide and Conquer, but unlike merge sort whose worst case time complexity is O(nlogn) , quick sort has a worst case time complexity of  O(n*n), but wait it is only a rare case and mostly it has time complexity is O(nlogn). I am sure you must be curious how can this be, you can dwell on it after you have read the algorithm, so go on read ahead.


<ResourceQuestion resource = "true" list={[{name:"Quick Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/tutorial"},]}/>



### Counting Sort

<ResourceQuestion resource = "true" list={[{name:"Counting Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial"},]}/>


### Radix Sort

<ResourceQuestion resource = "true" list={[{name:"Radix Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/tutorial"},]}/>



### Bubble Sort
Now that you have learnt about the faster sorting algorithms, you will be able to appreciate the simplicity of the slower sorting algorithms. Have an apprehension of all the algorithms you never know which one might come in handy. So go ahead and read the O(n*n) sorting algorithms


<ResourceQuestion resource = "true" list={[{name:"Bubble Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/tutorial"},]}/>



### Insertion Sort

<ResourceQuestion resource = "true" list={[{name:"Insertion Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/insertion-sort/tutorial"},]}/>



### Selection Sort

<ResourceQuestion resource = "true" list={[{name:"Selection Sort Hackerearth Tutorial",link:"https://www.hackerearth.com/practice/algorithms/sorting/selection-sort/tutorial"},]}/>



## Sorting custom data type using STL
So far you have seen sorting applied to primitive data types but what if you have a custom data type declared, can you use the STL sort() method then? The answer is YES, you can, but you will have to read on to find out how.

<ResourceQuestion resource = "true" list={[{name:"Sorting Custom Objects Using Cplusplus STL",link:"https://www.techiedelight.com/sort-vector-custom-objects-cpp/"},{name:"Sorting A Vector",link:"https://www.geeksforgeeks.org/sorting-a-vector-in-c/"},]}/>


## Questions

<Tabs
	defaultValue="medium"
	values={[{label: "Medium", value: "medium"},]}>
	<TabItem value="medium">
		<ResourceQuestion  list={[{name:"Inversion Of Array",link:"https://practice.geeksforgeeks.org/problems/inversion-of-array-1587115620/1"},{name:"Minimum Swaps",link:"https://practice.geeksforgeeks.org/problems/minimum-swaps/1"},]}/>
	</TabItem>
	
</Tabs>
